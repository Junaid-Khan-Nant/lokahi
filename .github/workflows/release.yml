name: release

# This triggers only when pull request is merged (closed) into branches of
# 'release/**'. The process is to create a new release branch from the previous
# release branch, then create a PR from develop branch to that new release.
# When all is approved, then merge and it should trigger this workflow. After
# which, merge new release branch into develop and develop merge into the
# various feature branches. Follows gitflow.
on:
  pull_request:
    branches: 
      - 'release/**'
    types: [closed]

# Tmp, just until I get something working. Develop this first, all pieces on
# release, then pull out what needed for other workflows.
#on:  
#  push:
#    branches:
#      - 'develop'

# For now, we have put all steps into a single job, this will allow for just
# one vm to run. We use actions to factor out the functionality. If there is a
# requirement to create additional jobs, maybe to run concurrent jobs, then we
# can split them up later.

jobs:
  release:
    runs-on: ubuntu-latest
    environment: docker-publish-account
    # Enviroment that contains the required secrets.
    steps:
      - name: Check out repository code
        uses: actions/checkout@v2
        # Is required to call actions.

      - name: init
        run: |

          # TODO: Filter the tag number off of the branch (release/tab_number),
          # put it as an env variable to be used through out below and passed
          # to actions for tagging the docker images after they are created.          
          echo "branch: " ${{ github.ref }}
          # The above github.ref, we expect this format: release/0.0.1.
          # If that changes, update the following statement.
          TAG=$(echo ${{ github.ref }} | sed -E  's/(.*)\/(.*)/\2/')
          echo "tag: " "$TAG" # Appears
          echo "RELEASE_TAG=$TAG" >> $GITHUB_ENV
          echo "release: " ${{ env.RELEASE_TAG }} # Not appears

          echo "hello from init on release" 
          echo "test 1" > tmp.test

      - name: feature-ui
        run: |
          # TODO: Need to create an action to run tests for this.

          echo "hello from feature-ui on release"
          cat tmp.test
          echo "test 2" >> tmp.test
          echo "tag: " "$TAG" # Not appears
          echo "release: " ${{ env.RELEASE_TAG }} # Appears

      - name: feature-core
        id: action-feature-core
        uses: ./.github/actions/core
        with:
          dir-location: 'platform'

      - name: feature-rest-server
        run: |
          # TODO: Need to create an action to run tests for this.

          echo "hello from feature-rest-server on release"
          cat tmp.test
          echo "test 4" >> tmp.test

      - name: external-it
        run: |
          cat tmp.test
          echo "test: " ${{ github.workspace }}
          pwd
          ls
 
          # Check that the image was created.
          docker images
          # Image from the action-feature-core shows up here.

          echo "test external-it"

          # IMPORTANT: Put the following into an action, it will be used for
          # branch develop merges and also release ones.

          ## Create cluster
          #kind create cluster
        
          ## Confirm cluster created
          ##kubectl config get-contexts
          ##kubectl get all
        
          ## Confirm versions
          ##java --version # JDK 11
          ##docker version
          ##kubectl -h
        
          ## Install skaffold and run skaffold 
          ## 
          ## TODO: Push docker image (save tar or something) to cluster, if good, then run the docker push at end of this.
          ## 
          ## TODO: Try this to test, but once the pipelines are up for creating
          ## images for each of the sub dirs in horizon stream, cache them as
          ## tar files and push them to the kind server and then update the
          ## kubernetes yaml files here and apply them through kubectl. In this
          ## way, we can remove skaffold and also use the docker images built
          ## and tested in previous workflows.
          #curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64 && \
          #sudo install skaffold /usr/local/bin/
          #kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/18.0.0/kubernetes/keycloaks.k8s.keycloak.org-v1.yml
          #kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/18.0.0/kubernetes/keycloakrealmimports.k8s.keycloak.org-v1.yml
          #kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/18.0.0/kubernetes/kubernetes.yml
          ## Verify (should get keycloaks and keycloakrealmiiimports)
          #kubectl api-resources | grep keycloak
          #skaffold run --port-forward --skip-tests &
          #  # Run env
          #sleep 240 
          #  # Wait for skaffold to deploy the horizon stream.
        
          ## Test
          #kubectl get all
        
          ## Cucumber test - TODO

      - name: dockerhub-login
        run: |

          # Login to dockerhub.
          #docker login -u ${{ secrets.DOCKERHUB_LOGIN }} -p ${{ secrets.DOCKERHUB_PASS }}
          echo ${{ secrets.DOCKERHUB_PASS }} | docker login -u ${{ secrets.DOCKERHUB_LOGIN }} --password-stdin

      - name: publish-image-core
        run: |

          # Login to dockerhub.
          #docker login -u ${{ secrets.DOCKERHUB_LOGIN }} -p ${{ secrets.DOCKERHUB_PASS }}
          echo ${{ secrets.DOCKERHUB_PASS }} | docker login -u ${{ secrets.DOCKERHUB_LOGIN }} --password-stdin

          # Publish core image
          cd platform/

          # Tag and save the image as a file to be published. Both release version and latest.
          docker tag opennms/horizon-stream-core:local opennms/horizon-stream-core:${{ env.RELEASE_TAG }}
          docker tag opennms/horizon-stream-core:local opennms/horizon-stream-core:latest

          docker push opennms/horizon-stream-core:${{ env.RELEASE_TAG }}
          docker push opennms/horizon-stream-core:latest

          # Put the following into the build before test action.
          #docker save -o horizon-stream-core-${{ env.RELEASE_TAG }}.tar opennms/horizon-stream-core:${{ env.RELEASE_TAG }}
          #docker save -o horizon-stream-core-latest.tar opennms/horizon-stream-core:latest

          ## Load image to docker hub. The image will go to the tag created at
          ## 'docker save' step.
          #docker load -i horizon-stream-core-${{ env.RELEASE_TAG }}.tar 
          #docker load -i horizon-stream-core-latest.tar 

          # TODO: Create a git tag for this branch as well.
      
      - name: publish-image-ui
        run: |

          # Login to dockerhub.
          #docker login -u ${{ secrets.DOCKERHUB_LOGIN }} -p ${{ secrets.DOCKERHUB_PASS }}
          echo ${{ secrets.DOCKERHUB_PASS }} | docker login -u ${{ secrets.DOCKERHUB_LOGIN }} --password-stdin

          # Publish core image
          cd ui/

          # Create the docker image.
          docker build -t opennms/horizon-stream-ui:${{ env.RELEASE_TAG }} -f ./dev/Dockerfile .

          # Tag and save the image as a file to be published. Both release version and latest.
          docker tag opennms/horizon-stream-ui:${{ env.RELEASE_TAG }} opennms/horizon-stream-ui:${{ env.RELEASE_TAG }}
          docker tag opennms/horizon-stream-ui:${{ env.RELEASE_TAG }} opennms/horizon-stream-ui:latest

          docker push opennms/horizon-stream-ui:${{ env.RELEASE_TAG }}
          docker push opennms/horizon-stream-ui:latest

          # Put the following into the build before test action.
          #docker save -o horizon-stream-ui-${{ env.RELEASE_TAG }}.tar opennms/horizon-stream-ui:${{ env.RELEASE_TAG }}
          #docker save -o horizon-stream-ui-latest.tar opennms/horizon-stream-ui:latest

          ## Load image to docker hub. The image will go to the tag created at
          ## 'docker save' step.
          #docker load -i horizon-stream-ui-${{ env.RELEASE_TAG }}.tar 
          #docker load -i horizon-stream-ui-latest.tar 

      - name: publish-image-rest-server
        run: |

          # Login to dockerhub.
          #docker login -u ${{ secrets.DOCKERHUB_LOGIN }} -p ${{ secrets.DOCKERHUB_PASS }}
          echo ${{ secrets.DOCKERHUB_PASS }} | docker login -u ${{ secrets.DOCKERHUB_LOGIN }} --password-stdin

          # When there are tests to run, put those in the actions for this.

          # Publish core image
          cd rest-server/

          # Create the docker image.
          mvn clean install jib:dockerBuild -Dimage=opennms/horizon-stream-rest-server:${{ env.RELEASE_TAG }}

          # Tag and save the image as a file to be published. Both release version and latest.
          docker tag opennms/horizon-stream-rest-server:${{ env.RELEASE_TAG }} opennms/horizon-stream-rest-server:${{ env.RELEASE_TAG }}
          docker tag opennms/horizon-stream-rest-server:${{ env.RELEASE_TAG }} opennms/horizon-stream-rest-server:latest

          docker push opennms/horizon-stream-rest-server:${{ env.RELEASE_TAG }}
          docker push opennms/horizon-stream-rest-server:latest

          # Put the following into the build before test action
          #docker save -o horizon-stream-rest-server-${{ env.RELEASE_TAG }}.tar opennms/horizon-stream-rest-server:${{ env.RELEASE_TAG }}
          #docker save -o horizon-stream-rest-server-latest.tar opennms/horizon-stream-rest-server:latest

          ## Load image to docker hub. The image will go to the tag created at
          ## 'docker save' step.
          #docker load -i horizon-stream-rest-server-${{ env.RELEASE_TAG }}.tar 
          #docker load -i horizon-stream-rest-server-latest.tar 
