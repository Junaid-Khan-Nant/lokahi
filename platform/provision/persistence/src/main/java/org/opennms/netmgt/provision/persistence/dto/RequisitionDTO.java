/*******************************************************************************
 * This file is part of OpenNMS(R).
 *
 * Copyright (C) 2009-2017 The OpenNMS Group, Inc.
 * OpenNMS(R) is Copyright (C) 1999-2017 The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * OpenNMS(R) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenNMS(R).  If not, see:
 *      http://www.gnu.org/licenses/
 *
 * For more information contact:
 *     OpenNMS(R) Licensing <license@opennms.org>
 *     http://www.opennms.org/
 *     http://www.opennms.com/
 *******************************************************************************/

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0.3-b01-fcs 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2009.01.29 at 01:15:48 PM EST 
//


package org.opennms.netmgt.provision.persistence.dto;

import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.Resource;

@Data
@Slf4j
public class RequisitionDTO implements Serializable {

    private static final long serialVersionUID = 1629774241824443273L;
    public static final String IMPORTED = "imported";

    protected Map<String, RequisitionNodeDTO> nodes = new HashMap<>();
    protected Date dateStamp = new Date();
    protected String foreignSource = IMPORTED;
    protected Date lastImport;
    private String id;

    /** the resource that this requisition was created from **/
    private transient Resource resource;

    /**
     * <p>Constructor for RequisitionDTO.</p>
     *
     * @param id a {@link String} object.
     */
    public RequisitionDTO(final String id) {
        this.id = id;
    }


    /**
     * <p>getNode</p>
     *
     * @param foreignId a {@link String} object.
     * @return a {@link RequisitionNodeDTO} object.
     */
    public RequisitionNodeDTO getNode(String foreignId) {
        return nodes.get(foreignId);
    }

    /**
     * <p>removeNode</p>
     *
     * @param node a {@link RequisitionNodeDTO} object.
     */
    public void deleteNode(RequisitionNodeDTO node) {
        deleteNode(node.getForeignId());
    }

    /**
     * <p>deleteNode</p>
     *
     * @param foreignId a {@link String} object.
     */
    public void deleteNode(final String foreignId) {
        nodes.remove(foreignId);
    }

    /**
     * <p>putNode</p>
     *
     * @param node a {@link RequisitionNodeDTO} object.
     */
    public void putNode(final RequisitionNodeDTO node) {
        nodes.put(node.getForeignId(), node);
    }

    /**
     * <p>updateDateStamp</p>
     */
    public void updateDateStamp() {
        dateStamp = new Date();
    }

    /**
     * <p>setForeignSource</p>
     *
     * @param value a {@link String} object.
     */
    public void setForeignSource(final String value) {
        if (value == null) {
            foreignSource = IMPORTED;
        }
        else {
            foreignSource = value;
        }
    }

    /**
     * Update the last imported stamp to the current date and time
     */
    public void updateLastImported() {
        lastImport = new Date();
    }
    
    /**
     * <p>getNodeCount</p>
     *
     * @return a int.
     */
    public int getNodeCount() {
        return nodes.size();
    }

//    @Override
//    public int hashCode() {
//        final int prime = 31;
//        int result = 1;
//        result = prime * result + ((m_dateStamp == null) ? 0 : m_dateStamp.hashCode());
//        result = prime * result + ((m_foreignSource == null) ? 0 : m_foreignSource.hashCode());
//        result = prime * result + ((m_lastImport == null) ? 0 : m_lastImport.hashCode());
//        result = prime * result + ((m_nodes == null) ? 0 : m_nodes.hashCode());
//        return result;
//    }

//    @Override
//    public boolean equals(final Object obj) {
//        if (this == obj) return true;
//        if (obj == null) return false;
//        if (!(obj instanceof RequisitionDTO))  return false;
//
//        final RequisitionDTO other = (RequisitionDTO) obj;
//        if (m_dateStamp == null) {
//            if (other.m_dateStamp != null) return false;
//        } else if (!m_dateStamp.equals(other.m_dateStamp)) {
//            return false;
//        }
//        if (m_foreignSource == null) {
//            if (other.m_foreignSource != null) return false;
//        } else if (!m_foreignSource.equals(other.m_foreignSource)) {
//            return false;
//        }
//        if (m_lastImport == null) {
//            if (other.m_lastImport != null) return false;
//        } else if (!m_lastImport.equals(other.m_lastImport)) {
//            return false;
//        }
//        if (m_nodes == null) {
//            if (other.m_nodes != null) return false;
//        } else if (!m_nodes.equals(other.m_nodes)) {
//            return false;
//        }
//        return true;
//    }

//    @Override
//    public String toString() {
//        return "RequisitionDTO [nodes="
//                + m_nodes + ", dateStamp=" + m_dateStamp
//                + ", foreignSource=" + m_foreignSource + ", lastImport="
//                + m_lastImport + "]";
//    }
    
    /**
     * Make sure that no data in the requisition is inconsistent.  Nodes should be unique,
     * interfaces should be unique per node, etc.
     */
//    public void validate() throws ValidationException {
//    	final Map<String,Integer> foreignSourceCounts = new HashMap<String,Integer>();
//    	final Set<String> errors = new HashSet<>();
//
//    	if (m_foreignSource == null) {
//    	    throw new ValidationException("RequisitionDTO 'foreign-source' must be set!");
//    	}
//    	if (m_foreignSource.contains("/")) {
//            throw new ValidationException("Foreign Source (" + m_foreignSource + ") contains invalid characters. ('/' is forbidden.)");
//    	}
//
//        // new ArrayList to prevent ConcurrentModificationException
//        for (final RequisitionNode node : new ArrayList<>(m_nodes)) {
//    		final String foreignId = node.getForeignId();
//    		node.validate();
//			Integer count = foreignSourceCounts.get(foreignId);
//			foreignSourceCounts.put(foreignId, count == null? 1 : ++count);
//    	}
//
//    	for (final Entry<String,Integer> entry : foreignSourceCounts.entrySet()) {
//    	    final String foreignId = entry.getKey();
//    		final Integer count = entry.getValue();
//    		if (count > 1) {
//    			errors.add( foreignId + " (" + count + " found)");
//    		}
//    	}
//
//    	if (errors.size() > 0) {
//    		final StringBuilder sb = new StringBuilder();
//    		sb.append("Duplicate nodes found on foreign source ").append(getForeignSource()).append(": ");
//    		final Iterator<String> it = errors.iterator();
//    		while (it.hasNext()) {
//    			final String error = it.next();
//    			sb.append(error);
//    			if (it.hasNext()) {
//    				sb.append(", ");
//    			}
//    		}
//    		throw new ValidationException(sb.toString());
//    	}
//    }
}
