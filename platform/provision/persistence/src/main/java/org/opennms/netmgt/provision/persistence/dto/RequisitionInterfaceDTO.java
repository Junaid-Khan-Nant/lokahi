/*******************************************************************************
 * This file is part of OpenNMS(R).
 *
 * Copyright (C) 2009-2022 The OpenNMS Group, Inc.
 * OpenNMS(R) is Copyright (C) 1999-2022 The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * OpenNMS(R) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenNMS(R).  If not, see:
 *      http://www.gnu.org/licenses/
 *
 * For more information contact:
 *     OpenNMS(R) Licensing <license@opennms.org>
 *     http://www.opennms.org/
 *     http://www.opennms.com/
 *******************************************************************************/

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.0.3-b01-fcs 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2009.01.29 at 01:15:48 PM EST 
//

package org.opennms.netmgt.provision.persistence.dto;

import java.net.InetAddress;
import java.util.HashMap;
//import javax.xml.bind.ValidationException;
import java.util.Map;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.opennms.horizon.core.lib.InetAddressUtils;
import org.opennms.horizon.db.model.PrimaryType;


/**
 * <p>RequisitionInterface class.</p>
 */
@Data
@Slf4j
public class RequisitionInterfaceDTO extends CategoriesAndMetadataDTO {

    private Map<String, RequisitionMonitoredServiceDTO> monitoredServices = new HashMap<>();
    private String description;
    //TODO: why an object?
    private Boolean managed;
    
    // annotated on the class, for some compatibility/initialization
    //TODO: this may cause a circular ref?
    private PrimaryType snmpPrimary;
    private Integer status;

    private InetAddress ipAddress;

    /**
     * <p>getMonitoredServiceCount</p>
     *
     * @return a int.
     */

//    @Transient
//    public int getMonitoredServiceCount() {
//        return monitoredServices.size();
//    }
//
//    /* backwards-compat with ModelImport */
//    /**
//     * <p>getMonitoredService</p>
//     *
//     * @return an array of {@link RequisitionMonitoredService} objects.
//     */
//    @Transient
//    public RequisitionMonitoredService[] getMonitoredService() {
//        return getMonitoredServices().toArray(new RequisitionMonitoredService[] {});
//    }

    /**
     * <p>getMonitoredService</p>
     *
     * @param serviceName a {@link String} object.
     * @return a {@link RequisitionMonitoredServiceDTO} object.
     */
    public RequisitionMonitoredServiceDTO getMonitoredService(String serviceName) {
        return monitoredServices.get(serviceName);
    }

    /**
     * <p>deleteMonitoredService</p>
     *
     * @param service a {@link RequisitionMonitoredServiceDTO} object.
     */
    public void deleteMonitoredService(RequisitionMonitoredServiceDTO service) {
        deleteMonitoredService(service.getServiceName());
    }

    /**
     * <p>deleteMonitoredService</p>
     *
     * @param serviceName a {@link String} object.
     */
    public void deleteMonitoredService(String serviceName) {
        monitoredServices.remove(serviceName);
    }

    /**
     * <p>putMonitoredService</p>
     *
     * @param service a {@link RequisitionMonitoredServiceDTO} object.
     */
    public void putMonitoredService(RequisitionMonitoredServiceDTO service) {
        monitoredServices.put(service.getServiceName(), service);
    }

    /**
     * <p>setIpAddr</p>
     *
     * @param value a {@link String} object.
     */
    public void setIpAddr(String value) {
        try {
            ipAddress = InetAddressUtils.getInetAddress(value);
        } catch (Throwable e) {
            throw new IllegalArgumentException(String.format("Invalid IP address specified: %s", value), e);
        }
    }

    /**
     * <p>isManaged</p>
     *
     * @return a boolean.
     */
    public boolean isManaged() {
        if (managed == null) {
            return true;
        } else {
            return managed;
        }
    }

    /**
     * <p>setSnmpPrimary</p>
     *
     * @param value a {@link String} object.
     */
    public void setSnmpPrimary(final PrimaryType value) {
        if (value != null) {
            snmpPrimary = value;
        }
        else {
            snmpPrimary = PrimaryType.NOT_ELIGIBLE;
        }
    }

    public void setStatus(Integer value) {
        if (value == null) {
            status = 1;
        }
        else {
            status = value;
        }
    }

    //TODO: fix
//    public void validate(RequisitionNode node) throws ValidationException {
//        if (m_ipAddress == null) {
//            if (m_ipAddressStr != null) {
//                try {
//                    m_ipAddress = new IPAddress(m_ipAddressStr).toInetAddress();
//                } catch (IllegalArgumentException iae) {
//                    LOG.warn(String.format("Invalid IP address %s", m_ipAddressStr));
//                    throw new IPValidationException(String.format("Invalid IP address %s", m_ipAddressStr), iae);
//                }
//            }
//            else {
//                throw new ValidationException("Requisition interface 'ip-addr' is a required attribute!");
//            }
//        }
//
//        if (m_monitoredServices != null) {
//            Set<String> serviceNameSet = new HashSet<>();
//            for (final RequisitionMonitoredService svc : m_monitoredServices) {
//                svc.validate();
//                if (!serviceNameSet.add(svc.getServiceName())) {
//                    throw new ValidationException(String.format("Duplicate service name: %s", svc.getServiceName()));
//                }
//            }
//        }
//
//        // there can be only one primary interface per node
//        if (m_snmpPrimary == PrimaryType.PRIMARY) {
//            long otherPrimaryInterfaces = node.getInterfaces().stream()
//                    .filter(iface -> PrimaryType.PRIMARY == iface.getSnmpPrimary())
//                    .filter(iface -> !iface.getIpAddr().equals(this.getIpAddr()))
//                    .count();
//            if (otherPrimaryInterfaces > 0) {
//                throw new ValidationException("Node foreign ID (" + node.getForeignId() + ") contains multiple primary interfaces. Maximum one is allowed.");
//            }
//        }
//    }

//    @Override
//    public int hashCode() {
//        final int prime = 67;
//        int result = 1;
//        result = prime * result + ((m_categories == null) ? 0 : m_categories.hashCode());
//        result = prime * result + ((m_metaData == null) ? 0 : m_metaData.hashCode());
//        result = prime * result + ((m_description == null) ? 0 : m_description.hashCode());
//        result = prime * result + ((m_ipAddress == null) ? 0 : m_ipAddress.hashCode());
//        result = prime * result + ((m_isManaged == null) ? 0 : m_isManaged.hashCode());
//        result = prime * result + ((m_monitoredServices == null) ? 0 : m_monitoredServices.hashCode());
//        result = prime * result + ((m_snmpPrimary == null) ? 0 : m_snmpPrimary.hashCode());
//        result = prime * result + ((m_status == null) ? 0 : m_status.hashCode());
//        return result;
//    }
//
//    @Override
//    public boolean equals(final Object obj) {
//        if (this == obj) return true;
//        if (obj == null) return false;
//        if (!(obj instanceof RequisitionInterface)) return false;
//        final RequisitionInterface other = (RequisitionInterface) obj;
//        if (m_categories == null) {
//            if (other.m_categories != null) return false;
//        } else if (!m_categories.equals(other.m_categories)) {
//            return false;
//        }
//        if (m_metaData == null) {
//            if (other.m_metaData != null) return false;
//        } else if (!m_metaData.equals(other.m_metaData)) {
//            return false;
//        }
//        if (m_description == null) {
//            if (other.m_description != null) return false;
//        } else if (!m_description.equals(other.m_description)) {
//            return false;
//        }
//        if (m_ipAddress == null) {
//            if (other.m_ipAddress != null) return false;
//        } else if (!m_ipAddress.equals(other.m_ipAddress)) {
//            return false;
//        }
//        if (m_isManaged == null) {
//            if (other.m_isManaged != null) return false;
//        } else if (!m_isManaged.equals(other.m_isManaged)) {
//            return false;
//        }
//        if (m_monitoredServices == null) {
//            if (other.m_monitoredServices != null) return false;
//        } else if (!m_monitoredServices.equals(other.m_monitoredServices)) {
//            return false;
//        }
//        if (m_snmpPrimary == null) {
//            if (other.m_snmpPrimary != null) return false;
//        } else if (!getSnmpPrimary().equals(other.getSnmpPrimary())) {
//            return false;
//        }
//        if (m_status == null) {
//            if (other.m_status != null) return false;
//        } else if (!m_status.equals(other.m_status)) {
//            return false;
//        }
//        return true;
//    }

//    @Override
//    public String toString() {
//        return "RequisitionInterface [monitoredServices="
//                + m_monitoredServices + ", categories=" + m_categories
//                + ", metaData=" + m_metaData
//                + ", description=" + m_description + ", ipAddress="
//                + m_ipAddress + ", isManaged=" + m_isManaged
//                + ", snmpPrimary=" + m_snmpPrimary + ", status="
//                + m_status + "]";
//    }

//    @Override
//    public int compareTo(final RequisitionInterface other) {
//        return new CompareToBuilder()
//            .append(ipAddress, other.ipAddress)
//            .append(status, other.status)
//            .append(managed, other.managed)
//            .append(getSnmpPrimary(), other.getSnmpPrimary())
//            .append(monitoredServices, other.monitoredServices)
//            .append(categories, other.categories)
//            .append(metaData, other.metaData)
//            .append(description, other.description)
//            .toComparison();
//    }
}
